/** *************************************************************************
 ** This data and information is proprietary to, and a valuable trade secret
 ** of, Basis Technology Corp. It is given in confidence by Basis Technology
 ** and may only be used as permitted under the license agreement under which
 ** it has been distributed, and in no other way.
 **
 ** Copyright (c) 2023 Basis Technology Corp. All rights reserved.
 **
 ** The technical data and information provided herein are provided with
 ** `limited rights', and the computer software provided herein is provided
 ** with `restricted rights' as those terms are defined in DAR and ASPR
 ** 7-104.9(a).
 ************************************************************************** */
package com.basistech.df.cybertriage.autopsy.malwarescan;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.Consumer;

/**
 * Processes a batch when number of items reaches batchSize or flush. Processing
 * blocks (and subsequently add and flush operations) until previous batch
 * finishes.
 */
public class BatchProcessor<T> {

    private final ExecutorService processingExecutorService = Executors.newSingleThreadExecutor();

    private final BlockingQueue<T> batchingQueue;
    private final List<T> processingQueue;
    private final int batchSize;
    private final Consumer<List<T>> itemsConsumer;
    private final long millisTimeout;

    private Future<?> lastProcessingFuture = CompletableFuture.runAsync(() -> {
    });

    public BatchProcessor(int batchSize, long millisTimeout, Consumer<List<T>> itemsConsumer) {
        this.batchingQueue = new LinkedBlockingQueue<>(batchSize);
        this.processingQueue = new ArrayList<>(batchSize);
        this.batchSize = batchSize;
        this.itemsConsumer = itemsConsumer;
        this.millisTimeout = millisTimeout;
    }

    public synchronized void clearCurrentBatch() {
        batchingQueue.clear();
    }
    
    public synchronized void flush(boolean blockUntilFinished) throws InterruptedException {
        asyncProcessBatch();
        if (blockUntilFinished) {
            lastProcessingFuture.wait(millisTimeout);
        }
    }

    public synchronized void add(T item) throws InterruptedException {
        batchingQueue.add(item);
        if (batchingQueue.size() >= batchSize) {
            asyncProcessBatch();
        }
    }

    private synchronized void asyncProcessBatch() throws InterruptedException {
        if (!batchingQueue.isEmpty()) {
            // wait for previous processing to finish
            lastProcessingFuture.wait(millisTimeout);

            // if 'andThen' doesn't run, clear the processing queue
            processingQueue.clear();

            // transfer batching queue to processing queue
            batchingQueue.drainTo(processingQueue);

            // submit to processor and then clear processing queue
            lastProcessingFuture = processingExecutorService.submit(
                    () -> itemsConsumer.andThen(processingQueue -> processingQueue.clear()).accept(processingQueue)
            );
        }
    }

}
