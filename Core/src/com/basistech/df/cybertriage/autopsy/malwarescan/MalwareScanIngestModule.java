/** *************************************************************************
 ** This data and information is proprietary to, and a valuable trade secret
 ** of, Basis Technology Corp. It is given in confidence by Basis Technology
 ** and may only be used as permitted under the license agreement under which
 ** it has been distributed, and in no other way.
 **
 ** Copyright (c) 2023 Basis Technology Corp. All rights reserved.
 **
 ** The technical data and information provided herein are provided with
 ** `limited rights', and the computer software provided herein is provided
 ** with `restricted rights' as those terms are defined in DAR and ASPR
 ** 7-104.9(a).
 ************************************************************************** */
package com.basistech.df.cybertriage.autopsy.malwarescan;

import com.basistech.df.cybertriage.autopsy.ctapi.CTApiDAO;
import com.basistech.df.cybertriage.autopsy.ctapi.json.AuthTokenResponse;
import com.basistech.df.cybertriage.autopsy.ctapi.json.AuthenticatedRequestData;
import com.basistech.df.cybertriage.autopsy.ctapi.json.CTCloudBean;
import com.basistech.df.cybertriage.autopsy.ctapi.json.LicenseInfo;
import com.basistech.df.cybertriage.autopsy.ctoptions.ctcloud.CTLicensePersistence;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.logging.Level;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.openide.util.NbBundle.Messages;
import org.sleuthkit.autopsy.casemodule.Case;
import org.sleuthkit.autopsy.coreutils.Logger;
import org.sleuthkit.autopsy.coreutils.MessageNotifyUtil;
import org.sleuthkit.autopsy.ingest.FileIngestModule;
import org.sleuthkit.autopsy.ingest.IngestJobContext;
import org.sleuthkit.autopsy.ingest.IngestModule;
import org.sleuthkit.autopsy.modules.filetypeid.FileTypeDetector;
import org.sleuthkit.datamodel.AbstractFile;
import org.sleuthkit.datamodel.AnalysisResult;
import org.sleuthkit.datamodel.Blackboard;
import org.sleuthkit.datamodel.BlackboardArtifact;
import org.sleuthkit.datamodel.Score;
import org.sleuthkit.datamodel.SleuthkitCase;
import org.sleuthkit.datamodel.TskData;

/**
 * Uses CT cloud API to determine if file is malware
 */
public class MalwareScanIngestModule implements FileIngestModule {

    private static final SharedProcessing sharedProcessing = new SharedProcessing();

    @Override
    public void startUp(IngestJobContext context) throws IngestModuleException {
        sharedProcessing.startUp(context);
    }

    @Override
    public ProcessResult process(AbstractFile af) {
        return sharedProcessing.process(af);
    }

    @Override
    public void shutDown() {
        sharedProcessing.shutDown();
    }

    /**
     * Does the bulk of processing for the ingest module and handles concurrent
     * ingest modules adding files simultaneously.
     */
    private static class SharedProcessing {

        // batch size of 200 files max
        private static final int BATCH_SIZE = 200;
        // 3 minute timeout for an API request
        private static final long BATCH_MILLIS_TIMEOUT = 3 * 60 * 1000;

        //minimum lookups left before issuing warning
        private static final long LOW_LOOKUPS_REMAINING = 250;

        private static final Set<String> EXECUTABLE_MIME_TYPES = Stream.of(
                "application/x-bat",//NON-NLS
                "application/x-dosexec",//NON-NLS
                "application/vnd.microsoft.portable-executable",//NON-NLS
                "application/x-msdownload",//NON-NLS
                "application/exe",//NON-NLS
                "application/x-exe",//NON-NLS
                "application/dos-exe",//NON-NLS
                "vms/exe",//NON-NLS
                "application/x-winexe",//NON-NLS
                "application/msdos-windows",//NON-NLS
                "application/x-msdos-program"//NON-NLS
        ).collect(Collectors.toSet());

        private static final String MALWARE_TYPE_NAME = "TSK_MALWARE";
        private static final String MALWARE_CONFIG = "Cyber Triage Cloud";

        private static final Logger logger = Logger.getLogger(MalwareScanIngestModule.class.getName());
        private final BatchProcessor<FileRecord> batchProcessor = new BatchProcessor<FileRecord>(BATCH_SIZE, BATCH_MILLIS_TIMEOUT, this::handleBatch);

        private final CTLicensePersistence ctSettingsPersistence = CTLicensePersistence.getInstance();
        private final CTApiDAO ctApiDAO = CTApiDAO.getInstance();

        private FileTypeDetector fileTypeDetector;
        private RunState runState = null;
        private SleuthkitCase tskCase = null;
        private LicenseInfo licenseInfo = null;
        private BlackboardArtifact.Type malwareType = null;
        private boolean noMoreHashLookups = false;
        private IngestModuleException startupException;
        private long dsId = 0;
        private long ingestJobId = 0;

        @Messages({
            "MalwareScanIngestModule_ShareProcessing_lowLimitWarning_title=Hash Lookups Low",
            "# {0} - remainingLookups",
            "MalwareScanIngestModule_ShareProcessing_lowLimitWarning_desc=This license only has {0} lookups remaining",
            "MalwareScanIngestModule_malwareTypeDisplayName=Malware"
        })
        synchronized void startUp(IngestJobContext context) throws IngestModuleException {
            // only run this code once per startup
            if (runState == RunState.STARTED_UP) {
                if (startupException != null) {
                    throw startupException;
                } else {
                    return;
                }
            }

            try {
                // get saved license
                Optional<LicenseInfo> licenseInfoOpt = ctSettingsPersistence.loadLicenseInfo();
                if (licenseInfoOpt.isEmpty() || licenseInfoOpt.get().getDecryptedLicense() == null) {
                    throw new IngestModuleException("No saved license was found");
                }

                AuthTokenResponse authTokenResponse = ctApiDAO.getAuthToken(licenseInfoOpt.get().getDecryptedLicense());
                // syncronously fetch malware scans info

                // determine lookups remaining
                long lookupsRemaining = remaining(authTokenResponse.getHashLookupLimit(), authTokenResponse.getHashLookupCount());
                if (lookupsRemaining <= 0) {
                    throw new IngestModuleException("There are no more file hash lookups for this license");
                } else if (lookupsRemaining < LOW_LOOKUPS_REMAINING) {
                    notifyWarning(
                            Bundle.MalwareScanIngestModule_ShareProcessing_lowLimitWarning_title(),
                            Bundle.MalwareScanIngestModule_ShareProcessing_lowLimitWarning_desc(lookupsRemaining),
                            null);
                }

                // setup necessary variables for processing
                tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();
                malwareType = tskCase.getBlackboard().getOrAddArtifactType(
                        MALWARE_TYPE_NAME,
                        Bundle.MalwareScanIngestModule_malwareTypeDisplayName(),
                        BlackboardArtifact.Category.ANALYSIS_RESULT);
                fileTypeDetector = new FileTypeDetector();
                dsId = context.getDataSource().getId();
                ingestJobId = context.getJobId();
                licenseInfo = licenseInfoOpt.get();
                startupException = null;
                noMoreHashLookups = false;
                runState = RunState.STARTED_UP;
            } catch (IngestModuleException ex) {
                startupException = ex;
                throw startupException;
            } catch (Exception ex) {
                startupException = new IngestModuleException("An exception occurred on MalwareScanIngestModule startup", ex);
                throw startupException;
            }
        }

        private static long remaining(Long limit, Long used) {
            limit = limit == null ? 0 : limit;
            used = used == null ? 0 : used;
            return limit - used;
        }

        @Messages({
            "MalwareScanIngestModule_ShareProcessing_batchTimeout_title=Batch Processing Timeout",
            "MalwareScanIngestModule_ShareProcessing_batchTimeout_desc=Batch processing timed out"
        })
        IngestModule.ProcessResult process(AbstractFile af) {
            try {
                if (af.getKnown() != TskData.FileKnown.KNOWN
                        && EXECUTABLE_MIME_TYPES.contains(StringUtils.defaultString(fileTypeDetector.getMIMEType(af)).trim().toLowerCase())) {
                    batchProcessor.add(new FileRecord(af.getId(), af.getMd5Hash()));

                }
                return ProcessResult.OK;
            } catch (InterruptedException ex) {
                notifyWarning(
                        Bundle.MalwareScanIngestModule_ShareProcessing_batchTimeout_title(),
                        Bundle.MalwareScanIngestModule_ShareProcessing_batchTimeout_desc(),
                        ex);
                return IngestModule.ProcessResult.ERROR;
            }
        }

        @Messages({
            "MalwareScanIngestModule_SharedProcessing_authTokenResponseError_title=Authentication API error",
            "# {0} - errorResponse",
            "MalwareScanIngestModule_SharedProcessing_authTokenResponseError_desc=Received error: ''{0}'' when fetching the API authentication token for the license",
            "MalwareScanIngestModule_SharedProcessing_repServicenResponseError_title=Lookup API error",
            "# {0} - errorResponse",
            "MalwareScanIngestModule_SharedProcessing_repServicenResponseError_desc=Received error: ''{0}'' when fetching hash lookup results",
            "MalwareScanIngestModule_SharedProcessing_exhaustedHashLookups_title=Hash Lookups Exhausted",
            "MalwareScanIngestModule_SharedProcessing_exhaustedHashLookups_desc=The remaining hash lookups for this license have been exhausted",
            "MalwareScanIngestModule_SharedProcessing_generalProcessingError_title=Hash Lookup Error",
            "MalwareScanIngestModule_SharedProcessing_generalProcessingError_desc=An error occurred while processing hash lookup results",})
        private void handleBatch(List<FileRecord> fileRecords) {
            if (fileRecords == null || fileRecords.isEmpty() || noMoreHashLookups) {
                return;
            }

            // create mapping of md5 to corresponding object ids as well as just the list of md5's
            Map<String, List<Long>> md5ToObjId = new HashMap<>();
            List<String> md5Hashes = new ArrayList<>();
            for (FileRecord fr : fileRecords) {
                if (fr == null || StringUtils.isBlank(fr.getMd5hash()) || fr.getObjId() <= 0) {
                    continue;
                }

                String sanitizedMd5 = sanitizedMd5(fr.getMd5hash());
                md5ToObjId
                        .computeIfAbsent(sanitizedMd5, (k) -> new ArrayList<>())
                        .add(fr.getObjId());

                md5Hashes.add(sanitizedMd5);
            }

            if (md5Hashes.isEmpty()) {
                return;
            }

            try {
                // get an auth token with the license
                AuthTokenResponse authTokenResponse = ctApiDAO.getAuthToken(licenseInfo.getDecryptedLicense());

                // make sure we are in bounds for the remaining scans
                long remainingScans = remaining(authTokenResponse.getHashLookupLimit(), authTokenResponse.getHashLookupCount());
                if (remainingScans <= 0) {
                    noMoreHashLookups = true;
                    notifyWarning(
                            Bundle.MalwareScanIngestModule_SharedProcessing_exhaustedHashLookups_title(),
                            Bundle.MalwareScanIngestModule_SharedProcessing_exhaustedHashLookups_desc(),
                            null);
                    return;
                }

                // if the size of this batch will exceed limit, shrink list to limit and fail after processing
                boolean exceededScanLimit = false;
                if (remainingScans < md5Hashes.size()) {
                    md5Hashes = md5Hashes.subList(0, (int) remainingScans);
                    exceededScanLimit = true;
                }

                // using auth token, get results
                List<CTCloudBean> repResult = ctApiDAO.getReputationResults(
                        new AuthenticatedRequestData(licenseInfo.getDecryptedLicense(), authTokenResponse),
                        md5Hashes
                );

                List<BlackboardArtifact> createdArtifacts = new ArrayList<>();
                if (!CollectionUtils.isEmpty(repResult)) {
                    SleuthkitCase.CaseDbTransaction trans = null;
                    try {
                        trans = tskCase.beginTransaction();
                        for (CTCloudBean result : repResult) {
                            String sanitizedMd5 = sanitizedMd5(result.getMd5HashValue());
                            List<Long> objIds = md5ToObjId.remove(sanitizedMd5);
                            if (objIds == null || objIds.isEmpty()) {
                                continue;
                            }

                            for (Long objId : objIds) {
                                AnalysisResult res = createAnalysisResult(objId, result, trans);
                                if (res != null) {
                                    createdArtifacts.add(res);
                                }
                            }
                        }

                        trans.commit();
                        trans = null;
                    } finally {
                        if (trans != null) {
                            trans.rollback();
                            createdArtifacts.clear();
                            trans = null;
                        }
                    }

                    if (!CollectionUtils.isEmpty(createdArtifacts)) {
                        tskCase.getBlackboard().postArtifacts(createdArtifacts, Bundle.MalwareScanIngestModuleFactory_displayName(), ingestJobId);
                    }
                    
                    // if we only processed part of the batch, after processing, notify that we are out of scans.
                    if (exceededScanLimit) {
                        noMoreHashLookups = true;
                        notifyWarning(
                                Bundle.MalwareScanIngestModule_SharedProcessing_exhaustedHashLookups_title(),
                                Bundle.MalwareScanIngestModule_SharedProcessing_exhaustedHashLookups_desc(),
                                null);
                        return;
                    }
                }
            } catch (Exception ex) {
                notifyWarning(
                        Bundle.MalwareScanIngestModule_SharedProcessing_generalProcessingError_title(),
                        Bundle.MalwareScanIngestModule_SharedProcessing_generalProcessingError_desc(),
                        ex);
            }
        }

        private String sanitizedMd5(String orig) {
            return StringUtils.defaultString(orig).trim().toLowerCase();
        }

        @Messages({
            "MalwareScanIngestModule_SharedProcessing_createAnalysisResult_Yes=YES",
            "MalwareScanIngestModule_SharedProcessing_createAnalysisResult_No=NO"
        })
        private AnalysisResult createAnalysisResult(Long objId, CTCloudBean cloudBean, SleuthkitCase.CaseDbTransaction trans) throws Blackboard.BlackboardException {
            if (objId == null || cloudBean == null || cloudBean.getMalwareResult() == null) {
                return null;
            }

            Score score = cloudBean.getMalwareResult().getCTScore() == null
                    ? Score.SCORE_UNKNOWN
                    : cloudBean.getMalwareResult().getCTScore().getTskCore();

            String conclusion = score.getSignificance() == Score.Significance.NOTABLE || score.getSignificance() == Score.Significance.LIKELY_NOTABLE
                    ? Bundle.MalwareScanIngestModule_SharedProcessing_createAnalysisResult_Yes()
                    : Bundle.MalwareScanIngestModule_SharedProcessing_createAnalysisResult_No();

            String justification = cloudBean.getMalwareResult().getStatusDescription();

            return tskCase.getBlackboard().newAnalysisResult(
                    malwareType,
                    objId,
                    dsId,
                    score,
                    conclusion,
                    MALWARE_CONFIG,
                    justification,
                    Collections.emptyList(),
                    trans).getAnalysisResult();
        }

        @Messages({
            "MalwareScanIngestModule_SharedProcessing_flushTimeout_title=Processing Timeout",
            "MalwareScanIngestModule_SharedProcessing_flushTimeout_desc=A timeout occurred while finishing processing"
        })
        synchronized void shutDown() {
            // if already shut down, return
            if (runState == RunState.SHUT_DOWN) {
                return;
            }

            // flush any remaining items
            try {
                batchProcessor.flush(true);
            } catch (InterruptedException ex) {
                notifyWarning(
                        Bundle.MalwareScanIngestModule_SharedProcessing_flushTimeout_title(),
                        Bundle.MalwareScanIngestModule_SharedProcessing_flushTimeout_desc(),
                        ex);
            } finally {
                // set state to shut down and clear any remaining
                noMoreHashLookups = false;
                runState = RunState.SHUT_DOWN;
                startupException = null;
                batchProcessor.clearCurrentBatch();
            }
        }

        private void notifyWarning(String title, String message, Exception ex) {
            MessageNotifyUtil.Notify.warn(title, message);
            logger.log(Level.WARNING, message, ex);
        }

        private enum RunState {
            STARTED_UP, SHUT_DOWN
        }

        class FileRecord {

            private final long objId;
            private final String md5hash;

            FileRecord(long objId, String md5hash) {
                this.objId = objId;
                this.md5hash = md5hash;
            }

            long getObjId() {
                return objId;
            }

            String getMd5hash() {
                return md5hash;
            }

        }
    }
}
